<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roter Zeiger - Das Spiel (3D Labyrinth)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #scoreboard {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div id="scoreboard">Finde die Kekse und drücke 'E', um sie aufzuheben!</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script>
        let camera, scene, renderer, controls;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let objects = [];
        let raycaster;
        let collectedCookies = 0;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let prevTime = performance.now();

        init();
        animate();

        function init() {
            // Szene und Kamera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Himmelblauer Hintergrund
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 4, 20); // Kamera initial weiter entfernt positionieren

            // Beleuchtung
            const ambientLight = new THREE.AmbientLight(0x404040); // Sanftes Umgebungslicht
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // Stärkeres Licht
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // PointerLockControls für First-Person-Steuerung
            controls = new THREE.PointerLockControls(camera, document.body);
            document.addEventListener('click', () => {
                controls.lock();
            });
            scene.add(controls.getObject());

            // Boden
            const floorGeometry = new THREE.PlaneGeometry(800, 800);
            const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // Wände
            const wallGeometry = new THREE.BoxGeometry(8, 8, 8);
            const wallMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            function addWall(x, z) {
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(x, 4, z);
                scene.add(wall);
                objects.push(wall);
            }

            // Einfaches Labyrinth
            addWall(0, 0);
            addWall(10, 0);
            addWall(0, 10);
            addWall(10, 10);

            // Kekse
            const cookieGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.5, 32);
            const cookieMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });

            function addCookie(x, z) {
                const cookie = new THREE.Mesh(cookieGeometry, cookieMaterial);
                cookie.position.set(x, 1, z);
                scene.add(cookie);
                objects.push(cookie);
            }

            addCookie(5, 5);

            // Raycaster für Kollisionserkennung
            raycaster = new THREE.Raycaster();

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Bewegungsevents
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function detectCollision() {
            raycaster.ray.origin.copy(camera.position);
            raycaster.ray.direction.set(0, -1, 0); // Nach unten strahlen

            const intersects = raycaster.intersectObjects(objects);
            for (const object of intersects) {
                if (object.object.geometry instanceof THREE.BoxGeometry) {
                    return true;
                }
            }
            return false;
        }

        function collectCookies() {
            raycaster.ray.origin.copy(camera.position);
            raycaster.ray.origin.y -= 4; // Spielerhöhe anpassen
            raycaster.ray.direction.set(0, -1, 0); // Nach unten strahlen

            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                const object = intersects[0].object;

                if (object.geometry instanceof THREE.CylinderGeometry) {
                    scene.remove(object);
                    objects = objects.filter(obj => obj !== object);
                    collectedCookies++;
                    document.getElementById('scoreboard').innerText = `Kekse gesammelt: ${collectedCookies}`;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (controls.isLocked) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                // Temporäre Position berechnen
                const tempPosition = camera.position.clone();
                if (moveForward || moveBackward) tempPosition.z -= direction.z * 200.0 * delta;
                if (moveLeft || moveRight) tempPosition.x -= direction.x * 200.0 * delta;

                // Überprüfe Kollision vor der tatsächlichen Bewegung
                if (!detectCollision()) {
                    controls.moveRight(-velocity.x * delta);
                    controls.moveForward(-velocity.z * delta);
                }

                prevTime = time;
            }

            renderer.render(scene, camera);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'KeyE':
                    collectCookies();
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }
    </script>
</body>
</html>